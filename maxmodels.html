<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>arduivis by cskonopka</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56095763-1', 'auto');
  ga('send', 'pageview');

</script>    
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://cskonopka.github.io/arduivis/">arduivis</h1>
        <p>modular microcontroller programming for visual programming languages</p>

        <p class="view"><a href="https://github.com/cskonopka/arduivis">View this Project on GitHub </a></p>
        
          
          <ul>
          <li><a href="http://cskonopka.github.io/arduivis/arduinomodels">Examples<strong>Arduino</strong></a></li>            
              <li><a href="http://cskonopka.github.io/arduivis/maxmodels">Models<strong>MaxMSP</strong></a></li>
              <li><a href="http://cskonopka.github.io/arduivis/pdmodels">Models<strong>PureData</strong></a></li>
            </ul>
   
      </header>
      <section>
<!--         <h3>
 -->

<!-- <pre><code>$ cd cskonopka/arduivis
$ git fetch origin
$ git checkout gh-pages
</code></pre>

<p>If you're using the GitHub for Mac, simply sync your repository and you'll see the new branch.</p>
 -->




<!-- <a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Methodology</h3>

<p>Each model represents a way to interact with an Arduino via a visual programming language. 

Currently there are 6 models that make up arduivis.</p>
  <ul>
    <li>model #1: output</li>
    <li>model #2: input</li>
    <li>model #3: feedback</li>
    <li>model #4: multiple ouputs</li>
    <li>model #5: multiple inputs</li>
    <li>model #6: multiple feedbacks</li>
  </ul> -->
<!-- 
<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Getting Started</h3>

 -->

 <h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>MaxMSP Models</h3>

  <ul>
        <li><a href="http://cskonopka.github.io/arduivis/maxmodel1"><em>model #1: output</em></li></a>
        <li><a href="http://cskonopka.github.io/arduivis/maxmodel2"><em>model #2: input</em></li></a>
        <li><a href="http://cskonopka.github.io/arduivis/maxmodel3"><em>model #3: feedback</em></li></a>
        <li><a href="http://cskonopka.github.io/arduivis/maxmodel4"><em>model #4: multipleOutputs</em></li></a>               
        <li><a href="http://cskonopka.github.io/arduivis/maxmodel5"><em>model #5: multipleInputs</em></li></a>   
        <li><a href="http://cskonopka.github.io/arduivis/maxmodel6"><em>model #6: multipleFeedbacks</em></li></a>  
  </ul>

<ul></ul>

<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Sketch Breakdown</h3>

<p>There are two main pieces of code that are essential for MaxMSP and an Arduino to communicate properly. The two environments communicate via the serial buffer but each language has a different way of handling the information that goes in and out of the serial buffer.</p>

<p><b>Serial Buffer Input (from MaxMSP, to Arduino)</b></p>
<p>To send information from MaxMSP to an Arduino board, use <em>Serial.parseInt()</em>. Many examples use <em>while-loops</em> and <em>Serial.read()</em> but for this example, <em>Serial.parseInt()</em> tends to work best with streaming data.</p>

<pre><code>// Parse incoming MaxMSP slider values
// from MaxMSP, to Arduino
  int input1 = Serial.parseInt();
</code></pre>

<p>This piece of code is to be placed in the main loop of the program but it can be inserted in other structures as well. When used outside of the main loop, within a function lets say, there can be unpredicted interactions depending how you structure <em>Serial.print(ln)</em> messages.</p>

<p>The easiest way to understand how this Arduino code works is to think of it as a list. The <em>Serial.parseInt()</em> message at the top of the list will always be the first and the second will be second and so on. When this list is created, the number of <em>Serial.parseInt()</em> messages relates to how many serial inputs will be created in MaxMSP.

       <img src="http://cskonopka.github.io/arduivis/arduivis_MaxMSP_inputmodel.png" alt="some_text">

<p>Above is an example of how to send slider information from MaxMSP to an Arduino. The slider information is first packed into a list so it can sent to the next object. This list is sent to the [atoi] object where it is converted from ASCII characters to integers. This conversion makes the slider values from MaxMSP accessible in the serial buffer. This newly converted message is then appended with a stop byte (<em>10</em>), making it a complete message the Arduino can understand. It is then routed from the [append] object and to the [serial] object in MaxMSP, where it is read by the Arduino. What ensures that this message from MaxMSP is properly being read and updated within the serial buffer, the [serial] object must be polled.</p>


       <img src="http://cskonopka.github.io/arduivis/arduivis_MaxMSP_inputmodel_clock.png" alt="some_text">


<p>This is a very important piece of the puzzle because it creates synchronous system that makes ths connection complete. The polling design is very specific to the flow of messages going to the Arduino. Previous to this, many designs were used but this one has proven to be the most stable. Below are some observations as to why constant polling design is necessary.</p>

<ul>
  <li>If the polling metronome is off, you can still send data to the Arduino but there is a drop off within 2 seconds. Every time a new value is sent, it is then forgotten. Thus, polling the [serial] object to update the serial buffer is essential</li>
  <li>The [atoi] object is used in a specific way. If the packed slider values were sent into the far right inlet, every value change would cause a clock conflict. When the polling metronome is on, there needs to be a distinguishable stream without interruption. The solution is using the far right outlet of the [atoi] object. This will store the message in memory and will output the converted message based on the polling metronomes dictated speed.
</ul>




<pre><code>
  /*
  ~ arduivis ~
  [modular microcontroller programming]

  This example code is in the public domain.
*/
    
// Fading LED
  int ledpin= 3;    

// Message #1 from incoming buffer
  int input1;  

void setup() 
{
  // Create/open serial port
    Serial.begin(9600);     

  // LED Output Mode
    pinMode(ledpin, OUTPUT);     
}

void loop() 
{
  // Parse incoming MaxMSP slider values
  // from MaxMSP, to Arduino
    input1 = Serial.parseInt();

  // Print values of input1 to serial buffer
  // Good for debuggin
  // from Arduino, to MaxMSP
    Serial.println(input1);

  // Write parsed values to LEDs
  // Fading LED
  // from MaxMSP, to Arduino
    analogWrite(ledpin, input1);
}  
</code></pre>
 




      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/cskonopka">cskonopka</a></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>